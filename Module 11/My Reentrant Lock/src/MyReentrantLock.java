public class MyReentrantLock
{
    /*
    Объект MyReentrantLock является монитором.
    Чтобы программа не зависала не стоит делать просто wait() внутри lock(). Таким образом первый же поток зайдет в lock(),
    уснёт и тоже самое будет с другими последующими потоками. Для того, чтобы lock() работал корректно необходимо условие,
    которое будет проверять состояние лока (замка) (заблокирован/не заблокирован). Если замок не заблокирован, то пометить
    состояние как "заблокирован" и выйти из метода. Если состояние замка помечено как "заблокирован", то поток следует усыпить.
    Метод unlock должен выставлять состояние в "не заблокиован" и будить все уснувшие потоки, но обязательно метод lock()
    должен быть синхронизирован, чтобы при все пробудившиеся потоки не пошли разом в метод lock. Если метод lock будет
    синхронизирован, то одновременно в него сможет пройти только один поток.
    Таким образом поток 1 начинает выполняться -> заходит в lock() -> видит, что состояние не заблокировано -> выставляет
    состояние в "заблокировано" и выходит из метода lock() -> выполняет count++ -> заходит в метод unlock() -> в методе
    unlock выставляется состояние "не заблокировано" и будит другие потоки, которые зашли за первым потоком в lock и т.к.
    поток 1 установил locked = true, то остальные потоки, зашедшие за ним - уснули. Далее поток 1 зашедший в unlock выставляет
    locked = false и будит все уснувшие потоки через notifyAll() -> Следующий поток повторит цикл, пока другие потоки будут спать,
    ожидая пробуждения. 
     */

    /*

     */
    private static volatile boolean locked = false;

    public void lock()
    {
        synchronized (this)
        {
            while (locked)
            {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            locked = true;
        }
    }

    public synchronized void unlock()
    {
        locked = false;
        notifyAll();
    }
}
